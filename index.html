<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>AI Magical Stardust Tree (Local Photos)</title>
    <style>
        /* èƒŒæ™¯è‰² - æ·±ç´«é»‘æ˜Ÿç©º */
        body { margin: 0; overflow: hidden; background: #160016; font-family: 'Segoe UI', sans-serif; }
        #container { width: 100vw; height: 100vh; }
        
        /* UI å±‚æ ·å¼ */
        #ui-layer { position: absolute; top: 20px; left: 20px; z-index: 10; color: #e8e34f; pointer-events: none; }
        .hint { background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; border: 1px solid #e8e34f; margin-bottom: 10px; backdrop-filter: blur(4px); }
        
        /* æ‘„åƒå¤´é¢„è§ˆæ¡† */
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px; border: 2px solid #e8e34f; border-radius: 12px; overflow: hidden; transform: scaleX(-1); }
        
        /* åŠ è½½æç¤º */
        #loading { position: fixed; top:0; left:0; width:100%; height:100%; background: #160016; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #e8e34f; z-index: 100; font-size: 24px; }
        #loading-sub { font-size: 16px; color: #9f1465; margin-top: 10px; }
    </style>
</head>
<body>

<div id="loading">
    <div>æ­£åœ¨å‡èšæ˜Ÿå°˜...</div>
    <div id="loading-sub">å°è¯•åŠ è½½æœ¬åœ°å›¾ç‰‡ä¸­...</div>
</div>

<div id="ui-layer">
    <div class="hint">
        <b>æ‰‹åŠ¿æ§åˆ¶è¯´æ˜:</b><br>
        âœŠ æ¡æ‹³ï¼šå‡èšæ˜Ÿå°˜ (Assemble)<br>
        ğŸ–ï¸ å¼ æ‰‹ï¼šæ•£å¼€ç…§ç‰‡ (Scatter)<br>
        ğŸ¤ æåˆ/æŠ“å–ï¼šç…§ç‰‡èšç„¦ (Focus)<br>
        ğŸ‘‹ ç§»åŠ¨ï¼šæ—‹è½¬è§†è§’
    </div>
</div>

<div id="video-container">
    <video id="input-video" playsinline></video>
</div>

<div id="container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@23.1.1/dist/tween.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/**
 * ==========================================================
 * ğŸŸ¢ è¯·åœ¨è¿™é‡Œä¿®æ”¹å›¾ç‰‡è·¯å¾„ ğŸŸ¢
 * ==========================================================
 * 1. ç¡®ä¿å›¾ç‰‡æ–‡ä»¶æ”¾åœ¨å’Œæœ¬ HTML æ–‡ä»¶ã€åŒä¸€ä¸ªæ–‡ä»¶å¤¹ã€‘ä¸‹
 * 2. åœ¨ä¸‹é¢çš„åˆ—è¡¨ä¸­å¡«å…¥å›¾ç‰‡çš„æ–‡ä»¶å
 */
const CONFIG = {
    // ğŸ”´ æ–°çš„é…ç½®æ–¹å¼
    photoConfig: {
        folder: 'photos',   // å›¾ç‰‡å­˜æ”¾çš„æ–‡ä»¶å¤¹åå­—
        maxCount: 50,       // ä½ æƒ³è®©ç¨‹åºå°è¯•æ‰«æçš„æœ€å¤§æ•°é‡ï¼ˆæ¯”å¦‚åªæ‰«å‰50å¼ ï¼‰
        extension: '.jpg'   // å›¾ç‰‡åç¼€ï¼Œå»ºè®®ç»Ÿä¸€ç”¨ .jpg
    },

    // ç²’å­é…ç½® (ä¿æŒä¸å˜)
    particleCount: 3000, 
    treeHeight: 30,
    treeRadius: 12,
    colors: {
        primary: 0xe8e34f,
        secondary: 0x9f1465
    }
};
let scene, camera, renderer, hands, pointsMesh;
let photoMeshes = []; // å­˜å‚¨ç…§ç‰‡Mesh
let currentState = 'CLOSE'; 
let particlesData = []; 
let targetCameraPos = new THREE.Vector3(0, 5, 45);

// Shader Uniforms
let gu = {
    time: { value: 0 },
    color1: { value: new THREE.Color(CONFIG.colors.primary) },
    color2: { value: new THREE.Color(CONFIG.colors.secondary) }
};

async function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x160016);
    scene.fog = new THREE.FogExp2(0x160016, 0.015);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.copy(targetCameraPos);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('container').appendChild(renderer.domElement);

    // åŸºç¡€å…‰ç…§ç¡®ä¿ç…§ç‰‡å¯è§
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambientLight);

    // 1. åˆ›å»ºæ˜Ÿå°˜æ ‘
    createStardustTree();
    
    // 2. åŠ è½½æœ¬åœ°å›¾ç‰‡
    loadLocalImages();

    // 3. å¯åŠ¨æ‰‹åŠ¿å’ŒåŠ¨ç”»
    initMediaPipe();
    animate();
    
    // éšè—åŠ è½½å±‚
    setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
    }, 1500);
}

/**
 * ğŸŸ¡ åŠ è½½æœ¬åœ°å›¾ç‰‡çš„æ ¸å¿ƒå‡½æ•°
 */
/**
 * ğŸŸ¡ è‡ªåŠ¨æ¢æµ‹åŠ è½½å›¾ç‰‡ (ç›²ç›’æ¨¡å¼)
 * åŸç†ï¼šå°è¯•åŠ è½½ photos/1.jpg åˆ° photos/50.jpg
 * å¦‚æœå›¾ç‰‡å­˜åœ¨å°±æ˜¾ç¤ºï¼Œä¸å­˜åœ¨å°±è‡ªåŠ¨è·³è¿‡
 */
function loadLocalImages() {
    const loader = new THREE.TextureLoader();
    const { folder, maxCount, extension } = CONFIG.photoConfig;

    // å¾ªç¯å°è¯•åŠ è½½ 1 åˆ° maxCount
    for (let i = 1; i <= maxCount; i++) {
        // æ‹¼å‡‘è·¯å¾„ï¼š photos/1.jpg
        const path = `${folder}/${i}${extension}`;

        loader.load(
            path,
            // 1. åŠ è½½æˆåŠŸï¼šåˆ›å»ºç…§ç‰‡ Mesh
            (texture) => {
                // ä¿æŒå›¾ç‰‡æ¯”ä¾‹é€»è¾‘
                let width = 5;
                let height = 5;
                if(texture.image.width > texture.image.height) {
                    height = width * (texture.image.height / texture.image.width);
                } else {
                    width = height * (texture.image.width / texture.image.height);
                }
                const aspectGeo = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    side: THREE.DoubleSide,
                    transparent: true 
                });
                
                const mesh = new THREE.Mesh(aspectGeo, material);
                
                // åˆå§‹éšè—
                mesh.position.set(0, 0, 0);
                mesh.scale.set(0.01, 0.01, 0.01);
                
                scene.add(mesh);
                photoMeshes.push(mesh); // åŠ å…¥åŠ¨ç”»æ•°ç»„
                
                console.log(`âœ… æˆåŠŸåŠ è½½: ${path}`);
            },
            
            // 2. åŠ è½½è¿›åº¦ (ä¸éœ€è¦)
            undefined,
            
            // 3. åŠ è½½å¤±è´¥ (éå¸¸é‡è¦ï¼šé™é»˜å¤„ç†)
            (err) => {
                // è¿™é‡Œæ˜¯æ­£å¸¸çš„ï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯åœ¨"çŒœ"å›¾ç‰‡ã€‚
                // å¦‚æœ photos/5.jpg ä¸å­˜åœ¨ï¼Œä¼šè§¦å‘è¿™é‡Œï¼Œæˆ‘ä»¬ä»€ä¹ˆéƒ½ä¸åšï¼Œç›´æ¥å¿½ç•¥ã€‚
                // console.log(`è·³è¿‡: ${path} (ä¸å­˜åœ¨)`); 
            }
        );
    }
}

/**
 * åˆ›å»ºæ˜Ÿå°˜ç²’å­ç³»ç»Ÿ (Shaderé€»è¾‘ä¿æŒä¸å˜)
 */
function createStardustTree() {
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const sizes = [];
    const shifts = [];

    function pushShift() {
        shifts.push(
            Math.random() * Math.PI,
            Math.random() * Math.PI * 2,
            (Math.random() * 0.9 + 0.1) * Math.PI * 0.1,
            Math.random() * 0.9 + 0.1
        );
    }

    for (let i = 0; i < CONFIG.particleCount; i++) {
        const pos = new THREE.Vector3(
            (Math.random() - 0.5) * 80,
            (Math.random() - 0.5) * 80,
            (Math.random() - 0.5) * 80
        );

        const ratio = i / CONFIG.particleCount;
        const angle = ratio * Math.PI * 50;
        const radius = (1 - ratio) * CONFIG.treeRadius; 
        const treePos = new THREE.Vector3(
            Math.cos(angle) * radius,
            ratio * CONFIG.treeHeight - 12,
            Math.sin(angle) * radius
        );
        treePos.x += (Math.random()-0.5) * 0.5;
        treePos.z += (Math.random()-0.5) * 0.5;

        particlesData.push({ current: pos.clone(), scatter: pos.clone(), tree: treePos });
        positions.push(pos.x, pos.y, pos.z);
        sizes.push(Math.random() * 1.5 + 0.5);
        pushShift();
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('sizes', new THREE.Float32BufferAttribute(sizes, 1));
    geometry.setAttribute('shift', new THREE.Float32BufferAttribute(shifts, 4));

    const material = new THREE.PointsMaterial({
        size: 0.25,
        transparent: true,
        depthTest: false,
        blending: THREE.AdditiveBlending,
        onBeforeCompile: shader => {
            shader.uniforms.time = gu.time;
            shader.uniforms.color1 = gu.color1;
            shader.uniforms.color2 = gu.color2;
            shader.vertexShader = `
                uniform float time;
                uniform vec3 color1;
                uniform vec3 color2;
                attribute float sizes;
                attribute vec4 shift;
                varying vec3 vColor;
                ${shader.vertexShader}
            `.replace(`gl_PointSize = size;`, `gl_PointSize = size * sizes;`)
             .replace(`#include <color_vertex>`, 
                `#include <color_vertex>
                float d = length(abs(position)/vec3(20., 30., 20.));
                d = clamp(d, 0., 1.);
                vColor = mix(color1, color2, d);`)
             .replace(`#include <begin_vertex>`, 
                `#include <begin_vertex>
                float t = time;
                float moveT = mod(shift.x + shift.z * t, 6.28318);
                float moveS = mod(shift.y + shift.z * t, 6.28318);
                transformed += vec3(cos(moveS) * sin(moveT), cos(moveT), sin(moveS) * sin(moveT)) * shift.w;`);
            shader.fragmentShader = `
                varying vec3 vColor;
                ${shader.fragmentShader}
            `.replace(`#include <clipping_planes_fragment>`, 
                `#include <clipping_planes_fragment>
                float d = length(gl_PointCoord.xy - 0.5);
                if (d > 0.5) discard;`)
             .replace(`vec4 diffuseColor = vec4( diffuse, opacity );`, 
                `vec4 diffuseColor = vec4(vColor, smoothstep(0.5, 0.1, d));`);
        }
    });

    pointsMesh = new THREE.Points(geometry, material);
    scene.add(pointsMesh);
}

/**
 * çŠ¶æ€åˆ‡æ¢ä¸åŠ¨ç”»
 */
function switchState(newState) {
    if (newState === currentState) return;
    currentState = newState;

    // 1. ç²’å­åŠ¨ç”»
    particlesData.forEach((p) => {
        const target = newState === 'CLOSE' ? p.tree : p.scatter;
        const duration = 1200 + Math.random() * 600; 
        new TWEEN.Tween(p.current)
            .to({ x: target.x, y: target.y, z: target.z }, duration)
            .easing(TWEEN.Easing.Quadratic.InOut)
            .start();
    });

    // 2. ç…§ç‰‡å¢™åŠ¨ç”»
    if (photoMeshes.length > 0) {
        photoMeshes.forEach((mesh, i) => {
            let targetPos, targetScale;
            
            if (newState === 'CLOSE') {
                // åˆæ‹¢ï¼šç…§ç‰‡è—åœ¨æ ‘ä¸­å¿ƒ
                targetPos = { x: 0, y: 0, z: 0 };
                targetScale = 0.01;
            } 
            else if (newState === 'SCATTER') {
                // å¼ æ‰‹ï¼šç…§ç‰‡ç¯ç»•æ•£å¼€
                // è®¡ç®—èºæ—‹åˆ†å¸ƒ
                const angle = i * 0.8; 
                const radius = 15 + Math.random() * 5;
                targetPos = { 
                    x: Math.cos(angle) * radius, 
                    y: (Math.random() - 0.5) * 20, 
                    z: Math.sin(angle) * radius 
                };
                // è®©ç…§ç‰‡æœå‘ä¸­å¿ƒ
                mesh.lookAt(0, 0, 0);
                targetScale = 1;
            } 
            else if (newState === 'FOCUS') {
                // æåˆï¼šè½®æ’­å±•ç¤ºæˆ–è€…å…¨éƒ¨æ‹‰è¿‘
                // è¿™é‡Œé€»è¾‘ç¨å¾®æ”¹ä¸€ä¸‹ï¼Œè®©æ‰€æœ‰ç…§ç‰‡æ’åˆ—åœ¨é¢å‰
                const cols = 4; // æ¯è¡Œ4å¼ 
                const row = Math.floor(i / cols);
                const col = i % cols;
                
                targetPos = { 
                    x: (col - 1.5) * 6, // æ¨ªå‘æ’åˆ—
                    y: 10 - row * 6,    // çºµå‘æ’åˆ—
                    z: 20               // æ”¾åœ¨ç›¸æœºå‰é¢
                };
                mesh.rotation.set(0, 0, 0); // æ­£å¯¹å±å¹•
                targetScale = 1.2;
            }
            
            new TWEEN.Tween(mesh.position).to(targetPos, 1000).easing(TWEEN.Easing.Back.Out).start();
            new TWEEN.Tween(mesh.scale).to({x: targetScale, y: targetScale, z: targetScale}, 1000).start();
            
            // å¦‚æœæ˜¯ Scatter çŠ¶æ€ï¼Œç»“æŸTweenåè®©å®ƒç¨å¾®é‡æ–°é¢å‘ä¸­å¿ƒï¼ˆä¿®æ­£Tweenè¦†ç›–çš„lookAtï¼‰
            if (newState === 'SCATTER') {
               // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œäº¤ç»™ update é‡Œçš„ lookAt
            }
        });
    }
}

let clock = new THREE.Clock();
function animate(time) {
    requestAnimationFrame(animate);
    TWEEN.update(time);
    const t = clock.getElapsedTime();
    gu.time.value = t * Math.PI;

    if (pointsMesh) {
        const positions = pointsMesh.geometry.attributes.position.array;
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const p = particlesData[i];
            positions[i * 3] = p.current.x;
            positions[i * 3 + 1] = p.current.y;
            positions[i * 3 + 2] = p.current.z;
        }
        pointsMesh.geometry.attributes.position.needsUpdate = true;
        
        if (currentState === 'CLOSE') {
            pointsMesh.rotation.y = t * 0.1;
        }
    }

    // åŠ¨æ€è°ƒæ•´ç…§ç‰‡æœå‘ï¼ˆä»…åœ¨æ•£å¼€æ¨¡å¼ä¸‹ä¸€ç›´æœå‘ä¸­å¿ƒï¼‰
    if(currentState === 'SCATTER') {
        photoMeshes.forEach(mesh => mesh.lookAt(0,0,0));
    }

    camera.position.lerp(targetCameraPos, 0.05);
    camera.lookAt(0, 0, 0);
    renderer.render(scene, camera);
}

// MediaPipe ä¿æŒä¸å˜
function initMediaPipe() {
    const videoElement = document.getElementById('input-video');
    hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
    hands.onResults(onResults);
    const cameraUtils = new Camera(videoElement, { onFrame: async () => await hands.send({ image: videoElement }), width: 640, height: 480 });
    cameraUtils.start();
}

function onResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        const isFist = landmarks[8].y > landmarks[6].y && landmarks[12].y > landmarks[10].y;
        const isSpread = landmarks[8].y < landmarks[5].y && landmarks[20].y < landmarks[17].y;
        const isPinch = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y) < 0.05;

        if (isFist) switchState('CLOSE');
        else if (isPinch) switchState('FOCUS');
        else if (isSpread) switchState('SCATTER');

        const handX = (landmarks[9].x - 0.5) * 2;
        const handY = (landmarks[9].y - 0.5) * 2;
        targetCameraPos.x = handX * 40;
        targetCameraPos.y = -handY * 30 + 5;
    }
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

init();
</script>
</body>
</html>
