<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>星尘旋涡 + 手势控制</title>
  <style>
    body { margin:0; overflow:hidden; background:#160016; font-family:sans-serif; }
    #videoCanvas { position:absolute; top:10px; left:10px; width:320px; height:240px; border-radius:8px; z-index:10; background:#000; }
    .ui { position:absolute; top:10px; right:10px; color:#fff; font-size:14px; z-index:10; background: rgba(0,0,0,0.4); padding:6px 10px; border-radius:8px; }
    button { margin-left:4px; }
  </style>
</head>
<body>
  <canvas id="videoCanvas" width="640" height="480"></canvas>
  <div class="ui">
    <div>缩放: <span id="scaleVal">1.00</span> | 旋转: <span id="rotVal">0°</span></div>
    <div>状态: <span id="status">准备中…</span></div>
    <button id="startBtn">开始摄像头</button>
    <button id="stopBtn" disabled>停止摄像头</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>
  <script type="module">
    import * as THREE from "https://cdn.skypack.dev/three@0.136.0";

    // === Three.js 星尘场景 ===
    let scene = new THREE.Scene();
    scene.background = new THREE.Color(0x160016);
    let camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight,1,1000);
    camera.position.set(0,4,21);
    let renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth,innerHeight);
    document.body.appendChild(renderer.domElement);

    let scale=1, rotation=0; // 星辰初始状态

    // 粒子颜色
    let gu = { time:{value:0}, color1:{value:new THREE.Color(0xe8e34f)}, color2:{value:new THREE.Color(0x9f1465)} };
    let sizes=[], shift=[], pts=[];
    function pushShift(){ shift.push(Math.random()*Math.PI, Math.random()*Math.PI*2, (Math.random()*0.9+0.1)*0.1*Math.PI, Math.random()*0.9+0.1); }
    for(let i=0;i<50000;i++){ sizes.push(Math.random()*1.5+0.5); pushShift(); pts.push(new THREE.Vector3().randomDirection().multiplyScalar(Math.random()*0.5+9.5)); }
    for(let i=0;i<100000;i++){ 
      let innerR=10, outerR=40; 
      let rand=Math.pow(Math.random(),1.5); 
      let radius=innerR+(outerR-innerR)*rand; 
      let angle=Math.random()*2*Math.PI; 
      let y=(Math.random()-0.5)*2; 
      pts.push(new THREE.Vector3(Math.cos(angle)*radius,y,Math.sin(angle)*radius)); 
      sizes.push(Math.random()*1.5+0.5); pushShift();
    }

    let g = new THREE.BufferGeometry().setFromPoints(pts);
    g.setAttribute("sizes", new THREE.Float32BufferAttribute(sizes,1));
    g.setAttribute("shift", new THREE.Float32BufferAttribute(shift,4));

    let m = new THREE.PointsMaterial({size:0.125, transparent:true, depthTest:false, blending:THREE.AdditiveBlending});
    let p = new THREE.Points(g,m);
    p.rotation.order="ZYX"; p.rotation.z=0.2;
    scene.add(p);

    let clock = new THREE.Clock();
    function animateThree(){
      let t = clock.getElapsedTime()*0.5;
      gu.time.value=t*Math.PI;
      p.rotation.y += 0.01; // 星辰连续旋转
      p.rotation.z = rotation*Math.PI/180; // 手腕旋转
      p.scale.set(scale,scale,scale); // 手势缩放
      renderer.render(scene,camera);
      requestAnimationFrame(animateThree);
    }
    animateThree();

    // === 手势摄像头 ===
    const videoCanvas = document.getElementById('videoCanvas');
    const ctx = videoCanvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const scaleValEl = document.getElementById('scaleVal');
    const rotValEl = document.getElementById('rotVal');

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');

    let gesture = { pinchStartDist:null, pinchStartScale:null, rotationStart:null };
    let video=null;

    const hands = new Hands({locateFile:file=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.6, minTrackingConfidence:0.5});
    hands.onResults(onHandsResults);

    startBtn.onclick = async ()=>{
      startBtn.disabled=true; stopBtn.disabled=false;
      video=document.createElement('video'); video.style.display='none';
      video.width=640; video.height=480; video.autoplay=true; video.playsInline=true;
      document.body.appendChild(video);
      try{
        const stream=await navigator.mediaDevices.getUserMedia({video:{width:640,height:480}});
        video.srcObject=stream; await video.play(); statusEl.textContent="摄像头已开启";
        frameLoop();
      }catch(err){ console.error(err); statusEl.textContent="无法打开摄像头:"+err.message; startBtn.disabled=false; stopBtn.disabled=true; }
    }

    stopBtn.onclick = ()=>{
      if(video && video.srcObject){ video.srcObject.getTracks().forEach(t=>t.stop()); video.remove(); video=null; }
      statusEl.textContent="已停止";
      startBtn.disabled=false; stopBtn.disabled=true;
    }

    async function frameLoop(){
      if(!video) return;
      ctx.clearRect(0,0,videoCanvas.width,videoCanvas.height);
      ctx.drawImage(video,0,0,videoCanvas.width,videoCanvas.height);
      await hands.send({image:video});
      requestAnimationFrame(frameLoop);
    }

    function landmarkToPoint(lm){ return {x:lm.x*videoCanvas.width, y:lm.y*videoCanvas.height}; }
    function getAngle(p1,p2){ return Math.atan2(p2.y-p1.y,p2.x-p1.x)*180/Math.PI; }

    function onHandsResults(results){
      if(!results.multiHandLandmarks || results.multiHandLandmarks.length===0){
        statusEl.textContent="未检测到手"; gesture.pinchStartDist=null; gesture.pinchStartScale=null; gesture.rotationStart=null; return;
      }
      statusEl.textContent="检测到手";

      const lm = results.multiHandLandmarks[0];
      const thumb = landmarkToPoint(lm[4]);
      const index = landmarkToPoint(lm[8]);
      const wrist = landmarkToPoint(lm[0]);

      // 绘制骨骼
      drawConnectors(ctx,lm,Hands.HAND_CONNECTIONS,{color:'#00FF00', lineWidth:2});
      drawLandmarks(ctx,lm,{color:'#FF0000', lineWidth:1});

      // 缩放
      const dist = Math.hypot(thumb.x-index.x, thumb.y-index.y);
      if(!gesture.pinchStartDist){ gesture.pinchStartDist=dist; gesture.pinchStartScale=scale; }
      let targetScale = gesture.pinchStartScale*(dist/gesture.pinchStartDist);
      targetScale=Math.max(0.2,Math.min(5,targetScale));
      scale += (targetScale-scale)*0.2; // 防抖
      scaleValEl.textContent=scale.toFixed(2);

      // 旋转
      const angle = getAngle(wrist,index);
      if(gesture.rotationStart===null) gesture.rotationStart=angle;
      let targetRot = angle - gesture.rotationStart;
      rotation += (targetRot-rotation)*0.2; // 防抖
      rotValEl.textContent=Math.round(rotation)+'°';
    }
  </script>
</body>
</html>
