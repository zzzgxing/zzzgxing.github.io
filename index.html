<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>AI Magical Stardust Tree</title>
    <style>
        /* èƒŒæ™¯è‰²ä¿®æ”¹ä¸ºæ˜Ÿå°˜æ—‹æ¶¡çš„æ·±è‰²èƒŒæ™¯ */
        body { margin: 0; overflow: hidden; background: #160016; font-family: 'Segoe UI', sans-serif; }
        #container { width: 100vw; height: 100vh; }
        #ui-layer { position: absolute; top: 20px; left: 20px; z-index: 10; color: #e8e34f; pointer-events: none; }
        .hint { background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; border: 1px solid #e8e34f; margin-bottom: 10px; backdrop-filter: blur(4px); }
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px; border: 2px solid #e8e34f; border-radius: 12px; overflow: hidden; transform: scaleX(-1); }
        #upload-btn { pointer-events: auto; background: #9f1465; color: white; border: none; padding: 10px 20px; cursor: pointer; border-radius: 5px; font-weight: bold; transition: 0.3s; }
        #upload-btn:hover { background: #b81b76; box-shadow: 0 0 10px #9f1465; }
        canvas { display: block; }
        #loading { position: fixed; top:0; left:0; width:100%; height:100%; background: #160016; display: flex; justify-content: center; align-items: center; color: #e8e34f; z-index: 100; font-size: 24px; }
    </style>
</head>
<body>

<div id="loading">æ­£åœ¨å‡èšæ˜Ÿå°˜...</div>

<div id="ui-layer">
    <div class="hint">
        <b>æ‰‹åŠ¿æ§åˆ¶è¯´æ˜:</b><br>
        âœŠ æ¡æ‹³ï¼šå‡èšæ˜Ÿå°˜ (Assemble)<br>
        ğŸ–ï¸ å¼ æ‰‹ï¼šæ•£å¼€ç²’å­ (Scatter)<br>
        ğŸ¤ æåˆ/æŠ“å–ï¼šæŸ¥çœ‹ç…§ç‰‡ (Focus)<br>
        ğŸ‘‹ ç§»åŠ¨ï¼šæ—‹è½¬è§†è§’
    </div>
    <input type="file" id="image-upload" multiple accept="image/*" style="display:none">
    <button id="upload-btn" onclick="document.getElementById('image-upload').click()">ä¸Šä¼ æ‚¨çš„ç…§ç‰‡äº‘</button>
</div>

<div id="video-container">
    <video id="input-video" playsinline></video>
</div>

<div id="container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@23.1.1/dist/tween.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/**
 * æ ¸å¿ƒé…ç½® - é¢œè‰²å·²æ›´æ–°ä¸ºæ˜Ÿå°˜é£æ ¼
 */
const CONFIG = {
    particleCount: 3000, // ç²’å­æ•°é‡å¯ä»¥ç¨å¾®å¤šä¸€ç‚¹ï¼Œå› ä¸ºPointsæ¸²æŸ“å¾ˆå¿«
    treeHeight: 30,
    treeRadius: 12,
    colors: {
        primary: 0xe8e34f,  // é¢œè‰²1ï¼šé‡‘é»„
        secondary: 091465   // é¢œè‰²2ï¼šç«çº¢
    }
};

let scene, camera, renderer, hands, pointsMesh, photoMeshes = [];
let currentState = 'CLOSE'; 
let particlesData = []; // å­˜å‚¨ç²’å­çš„é€»è¾‘ä½ç½®æ•°æ®
let targetCameraPos = new THREE.Vector3(0, 5, 45);

// Shader Uniforms å…¨å±€å˜é‡
let gu = {
    time: { value: 0 },
    color1: { value: new THREE.Color(0xe8e34f) },
    color2: { value: new THREE.Color(0x9f1465) }
};

async function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x160016); // æ·±ç´«é»‘èƒŒæ™¯
    // æ·»åŠ ä¸€ç‚¹é›¾æ•ˆå¢å¼ºæ™¯æ·±
    scene.fog = new THREE.FogExp2(0x160016, 0.015);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.copy(targetCameraPos);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('container').appendChild(renderer.domElement);

    // ä¾ç„¶ä¿ç•™åŸºæœ¬å…‰ç…§ç»™ç…§ç‰‡å¢™ä½¿ç”¨
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);

    createStardustTree();
    initMediaPipe();
    animate();
    
    document.getElementById('loading').style.display = 'none';
}

/**
 * åˆ›å»ºæ˜Ÿå°˜ç²’å­ç³»ç»Ÿ (THREE.Points + Custom Shader)
 */
function createStardustTree() {
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const sizes = [];
    const shifts = []; // ç”¨äºShaderä¸­çš„éšæœºå¾®åŠ¨

    // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆ Shift æ•°æ® (æ¥è‡ªå‚è€ƒä»£ç )
    function pushShift() {
        shifts.push(
            Math.random() * Math.PI,
            Math.random() * Math.PI * 2,
            (Math.random() * 0.9 + 0.1) * Math.PI * 0.1,
            Math.random() * 0.9 + 0.1
        );
    }

    for (let i = 0; i < CONFIG.particleCount; i++) {
        // 1. åˆå§‹æ•£è½ä½ç½®
        const pos = new THREE.Vector3(
            (Math.random() - 0.5) * 80,
            (Math.random() - 0.5) * 80,
            (Math.random() - 0.5) * 80
        );

        // 2. åœ£è¯æ ‘å½¢æ€è®¡ç®—
        const ratio = i / CONFIG.particleCount;
        const angle = ratio * Math.PI * 50; // èºæ—‹åœˆæ•°
        const radius = (1 - ratio) * CONFIG.treeRadius; 
        const treePos = new THREE.Vector3(
            Math.cos(angle) * radius,
            ratio * CONFIG.treeHeight - 12,
            Math.sin(angle) * radius
        );
        
        // ç¨å¾®æ‰“ä¹±ä¸€ç‚¹æ ‘çš„è§„åˆ™æ€§ï¼Œè®©å®ƒçœ‹èµ·æ¥æ›´åƒæ˜Ÿäº‘
        treePos.x += (Math.random()-0.5) * 0.5;
        treePos.z += (Math.random()-0.5) * 0.5;

        // å­˜å‚¨é€»è¾‘æ•°æ®ç”¨äºTweenåŠ¨ç”»
        particlesData.push({
            current: pos.clone(), // å½“å‰æ˜¾ç¤ºä½ç½®
            scatter: pos.clone(), // æ•£å¼€ç›®æ ‡
            tree: treePos,        // æ ‘å½¢ç›®æ ‡
        });

        // å¡«å…… BufferGeometry æ•°æ®
        positions.push(pos.x, pos.y, pos.z);
        sizes.push(Math.random() * 1.5 + 0.5);
        pushShift();
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('sizes', new THREE.Float32BufferAttribute(sizes, 1));
    geometry.setAttribute('shift', new THREE.Float32BufferAttribute(shifts, 4));

    // æè´¨å®šä¹‰ï¼šå®Œå…¨å¤ç”¨å‚è€ƒä»£ç çš„ Shader é€»è¾‘
    const material = new THREE.PointsMaterial({
        size: 0.25, // ç¨å¾®è°ƒå¤§ä¸€ç‚¹åŸºç¡€å¤§å°
        transparent: true,
        depthTest: false, // å…³é—­æ·±åº¦æµ‹è¯•ä»¥è·å¾—æ›´å¥½çš„å åŠ å‘å…‰æ•ˆæœ
        blending: THREE.AdditiveBlending, // å…³é”®ï¼šåŠ æ³•æ··åˆå®ç°å‘å…‰
        onBeforeCompile: shader => {
            shader.uniforms.time = gu.time;
            shader.uniforms.color1 = gu.color1;
            shader.uniforms.color2 = gu.color2;

            shader.vertexShader = `
                uniform float time;
                uniform vec3 color1;
                uniform vec3 color2;
                attribute float sizes;
                attribute vec4 shift;
                varying vec3 vColor;
                ${shader.vertexShader}
            `
            .replace(
                `gl_PointSize = size;`,
                `gl_PointSize = size * sizes;`
            )
            .replace(
                `#include <color_vertex>`,
                `#include <color_vertex>
                // è®¡ç®—è·ç¦»ä¸­å¿ƒçš„è·ç¦»ï¼Œç”¨äºé¢œè‰²æ··åˆ
                float d = length(abs(position)/vec3(20., 30., 20.)); // è°ƒæ•´æ··åˆèŒƒå›´é€‚åº”æ ‘çš„å¤§å°
                d = clamp(d, 0., 1.);
                vColor = mix(color1, color2, d);`
            )
            .replace(
                `#include <begin_vertex>`,
                `#include <begin_vertex>
                float t = time;
                // æ·»åŠ åŸæœ¬çš„å¾®åŠ¨æ•ˆæœ
                float moveT = mod(shift.x + shift.z * t, 6.28318);
                float moveS = mod(shift.y + shift.z * t, 6.28318);
                transformed += vec3(cos(moveS) * sin(moveT), cos(moveT), sin(moveS) * sin(moveT)) * shift.w;
                `
            );

            shader.fragmentShader = `
                varying vec3 vColor;
                ${shader.fragmentShader}
            `
            .replace(
                `#include <clipping_planes_fragment>`,
                `#include <clipping_planes_fragment>
                float d = length(gl_PointCoord.xy - 0.5);
                // åœ†å½¢ç²’å­è£åˆ‡
                if (d > 0.5) discard;
                `
            )
            .replace(
                `vec4 diffuseColor = vec4( diffuse, opacity );`,
                `// è¾¹ç¼˜æŸ”åŒ–
                vec4 diffuseColor = vec4(vColor, smoothstep(0.5, 0.1, d));`
            );
        }
    });

    pointsMesh = new THREE.Points(geometry, material);
    scene.add(pointsMesh);
}

/**
 * æ‰‹åŠ¿çŠ¶æ€åˆ‡æ¢é€»è¾‘
 */
function switchState(newState) {
    if (newState === currentState) return;
    currentState = newState;

    // è§¦å‘ TWEEN åŠ¨ç”»æ›´æ–° particlesData ä¸­çš„ current å‘é‡
    particlesData.forEach((p) => {
        const target = newState === 'CLOSE' ? p.tree : p.scatter;
        
        // ç¨å¾®éšæœºåŒ–åŠ¨ç”»æ—¶é—´ï¼Œçœ‹èµ·æ¥æ›´è‡ªç„¶
        const duration = 1200 + Math.random() * 600; 

        new TWEEN.Tween(p.current)
            .to({ x: target.x, y: target.y, z: target.z }, duration)
            .easing(TWEEN.Easing.Quadratic.InOut)
            .start();
    });

    // ç…§ç‰‡å¢™é€»è¾‘ä¿æŒä¸å˜
    photoMeshes.forEach((mesh, i) => {
        let targetPos, targetScale;
        if (newState === 'CLOSE') {
            targetPos = { x: 0, y: 0, z: 0 };
            targetScale = 0.01;
        } else if (newState === 'SCATTER') {
            targetPos = { 
                x: Math.sin(i) * 15, 
                y: Math.cos(i * 1.5) * 15, 
                z: Math.tan(Math.sin(i)) * 5 
            };
            targetScale = 1;
        } else if (newState === 'FOCUS' && i === 0) {
            targetPos = { x: 0, y: 5, z: 25 }; // è°ƒæ•´èšç„¦ä½ç½®
            targetScale = 3;
        }
        
        new TWEEN.Tween(mesh.position).to(targetPos, 1000).start();
        new TWEEN.Tween(mesh.scale).to({x: targetScale, y: targetScale, z: targetScale}, 1000).start();
    });
}

/**
 * åŠ¨ç”»å¾ªç¯
 */
let clock = new THREE.Clock();
function animate(time) {
    requestAnimationFrame(animate);
    TWEEN.update(time);

    const t = clock.getElapsedTime();
    gu.time.value = t * Math.PI; // æ›´æ–° Shader æ—¶é—´

    // æ ¸å¿ƒé€»è¾‘ï¼šå°† TWEEN æ›´æ–°åçš„é€»è¾‘åæ ‡åŒæ­¥åˆ° BufferGeometry
    if (pointsMesh) {
        const positions = pointsMesh.geometry.attributes.position.array;
        
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const p = particlesData[i];
            
            // å°†é€»è¾‘ä½ç½®èµ‹å€¼ç»™æ¸²æŸ“ä½ç½®
            positions[i * 3] = p.current.x;
            positions[i * 3 + 1] = p.current.y;
            positions[i * 3 + 2] = p.current.z;
        }
        
        // æ ‡è®°ä½ç½®å±æ€§éœ€è¦æ›´æ–°
        pointsMesh.geometry.attributes.position.needsUpdate = true;

        // æ•´ä½“æ—‹è½¬ï¼ˆä»…åœ¨åˆæ‹¢çŠ¶æ€ä¸‹ï¼Œå¢åŠ è§‚èµæ€§ï¼‰
        if (currentState === 'CLOSE') {
            pointsMesh.rotation.y = t * 0.1;
        }
    }

    // ç›¸æœºå¹³æ»‘ç§»åŠ¨
    camera.position.lerp(targetCameraPos, 0.05);
    camera.lookAt(0, 0, 0);

    renderer.render(scene, camera);
}

/**
 * ç…§ç‰‡ä¸Šä¼ é€»è¾‘ (ä¿æŒä¸å˜)
 */
document.getElementById('image-upload').addEventListener('change', (e) => {
    const files = Array.from(e.target.files);
    photoMeshes.forEach(p => scene.remove(p));
    photoMeshes = [];

    files.forEach((file, index) => {
        const url = URL.createObjectURL(file);
        new THREE.TextureLoader().load(url, (tex) => {
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, transparent: true });
            const geo = new THREE.PlaneGeometry(4, 4);
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(0, 0, 0);
            mesh.scale.set(0.01, 0.01, 0.01);
            scene.add(mesh);
            photoMeshes.push(mesh);
        });
    });
});

/**
 * MediaPipe åˆå§‹åŒ–ä¸é€»è¾‘ (ä¿æŒä¸å˜)
 */
function initMediaPipe() {
    const videoElement = document.getElementById('input-video');
    hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });
    hands.onResults(onResults);
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => await hands.send({ image: videoElement }),
        width: 640,
        height: 480
    });
    cameraUtils.start();
}

function onResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        const isFist = landmarks[8].y > landmarks[6].y && landmarks[12].y > landmarks[10].y;
        const isSpread = landmarks[8].y < landmarks[5].y && landmarks[20].y < landmarks[17].y;
        const isPinch = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y) < 0.05;

        if (isFist) switchState('CLOSE');
        else if (isPinch) switchState('FOCUS');
        else if (isSpread) switchState('SCATTER');

        // æ‰‹åŠ¿æ§åˆ¶è§†è§’
        const handX = (landmarks[9].x - 0.5) * 2;
        const handY = (landmarks[9].y - 0.5) * 2;
        targetCameraPos.x = handX * 40;
        targetCameraPos.y = -handY * 30 + 5;
    }
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

init();
</script>
</body>
</html>
