<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>AI Gesture Christmas Tree - 2026</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050a05; font-family: 'Segoe UI', sans-serif; }
        #container { width: 100vw; height: 100vh; }
        #ui-layer { position: absolute; top: 20px; left: 20px; z-index: 10; color: #d4af37; pointer-events: none; }
        .hint { background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; border: 1px solid #d4af37; margin-bottom: 10px; }
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px; border: 2px solid #d4af37; border-radius: 12px; overflow: hidden; transform: scaleX(-1); }
        #upload-btn { pointer-events: auto; background: #c41e3a; color: white; border: none; padding: 10px 20px; cursor: pointer; border-radius: 5px; font-weight: bold; }
        canvas { display: block; }
        #loading { position: fixed; top:0; left:0; width:100%; height:100%; background: #000; display: flex; justify-content: center; align-items: center; color: #d4af37; z-index: 100; font-size: 24px; }
    </style>
</head>
<body>

<div id="loading">æ­£åœ¨åŠ è½½é­”æ³•åœ£è¯...</div>

<div id="ui-layer">
    <div class="hint">
        <b>æ‰‹åŠ¿æ§åˆ¶è¯´æ˜:</b><br>
        âœŠ æ¡æ‹³ï¼šåˆæ‹¢åœ£è¯æ ‘ (Assemble)<br>
        ğŸ–ï¸ å¼ æ‰‹ï¼šæ•£å¼€ç²’å­ (Scatter)<br>
        ğŸ¤ æåˆ/æŠ“å–ï¼šæŸ¥çœ‹ç…§ç‰‡ (Focus)<br>
        ğŸ‘‹ ç§»åŠ¨ï¼šæ—‹è½¬è§†è§’
    </div>
    <input type="file" id="image-upload" multiple accept="image/*" style="display:none">
    <button id="upload-btn" onclick="document.getElementById('image-upload').click()">ä¸Šä¼ æ‚¨çš„ç…§ç‰‡äº‘</button>
</div>

<div id="video-container">
    <video id="input-video" playsinline></video>
</div>

<div id="container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@23.1.1/dist/tween.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/**
 * æ ¸å¿ƒé€»è¾‘é…ç½®
 */
const CONFIG = {
    particleCount: 1200,
    treeHeight: 25,
    treeRadius: 10,
    colors: {
        matteGreen: 0x1a3c1a,
        metallicGold: 0xd4af37,
        christmasRed: 0xc41e3a
    }
};

let scene, camera, renderer, hands, instancedMesh, photoGroup;
let currentState = 'CLOSE'; // 'CLOSE', 'SCATTER', 'FOCUS'
let particles = [];
let photoMeshes = [];
let targetCameraPos = new THREE.Vector3(0, 10, 40);

// åˆå§‹åŒ–
async function init() {
    // åœºæ™¯åŸºç¡€
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050a05, 0.02);
    
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.copy(targetCameraPos);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ReinhardToneMapping;
    document.getElementById('container').appendChild(renderer.domElement);

    // å…‰å½±æ•ˆæœ
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(CONFIG.colors.metallicGold, 2, 100);
    pointLight.position.set(0, 20, 10);
    scene.add(pointLight);

    createTreeParticles();
    initMediaPipe();
    animate();
    
    document.getElementById('loading').style.display = 'none';
}

/**
 * åˆ›å»ºåœ£è¯æ ‘ç²’å­ (InstancedMesh)
 */
function createTreeParticles() {
    const geometries = [
        new THREE.SphereGeometry(0.2, 8, 8),
        new THREE.BoxGeometry(0.3, 0.3, 0.3),
        new THREE.CylinderGeometry(0.05, 0.05, 0.5) // ç®€åŒ–ç‰ˆç³–æœæ£
    ];

    const material = new THREE.MeshStandardMaterial({
        metalness: 0.8,
        roughness: 0.2,
        vertexColors: true
    });

    instancedMesh = new THREE.InstancedMesh(geometries[0], material, CONFIG.particleCount);
    
    const dummy = new THREE.Object3D();
    const color = new THREE.Color();

    for (let i = 0; i < CONFIG.particleCount; i++) {
        // åˆå§‹ä½ç½®ï¼šéšæœºæ•£è½
        const pos = new THREE.Vector3(
            (Math.random() - 0.5) * 60,
            (Math.random() - 0.5) * 60,
            (Math.random() - 0.5) * 60
        );
        
        // è®¡ç®—åœ£è¯æ ‘å½¢æ€çš„ç›®æ ‡ä½ç½® (åœ†é”¥ä½“)
        const ratio = i / CONFIG.particleCount;
        const angle = ratio * Math.PI * 40;
        const radius = (1 - ratio) * CONFIG.treeRadius;
        const treePos = new THREE.Vector3(
            Math.cos(angle) * radius,
            ratio * CONFIG.treeHeight - 10,
            Math.sin(angle) * radius
        );

        particles.push({
            current: pos.clone(),
            scatter: pos.clone(),
            tree: treePos,
            size: Math.random() * 1.5 + 0.5
        });

        dummy.position.copy(pos);
        dummy.updateMatrix();
        instancedMesh.setMatrixAt(i, dummy.matrix);
        
        // éšæœºåˆ†é…é…è‰²æ–¹æ¡ˆ
        const rand = Math.random();
        if (rand > 0.6) color.setHex(CONFIG.colors.matteGreen);
        else if (rand > 0.2) color.setHex(CONFIG.colors.metallicGold);
        else color.setHex(CONFIG.colors.christmasRed);
        instancedMesh.setColorAt(i, color);
    }
    
    scene.add(instancedMesh);
}

/**
 * ç…§ç‰‡ä¸Šä¼ ä¸å¤„ç†
 */
document.getElementById('image-upload').addEventListener('change', (e) => {
    const files = Array.from(e.target.files);
    photoMeshes.forEach(p => scene.remove(p));
    photoMeshes = [];

    files.forEach((file, index) => {
        const url = URL.createObjectURL(file);
        new THREE.TextureLoader().load(url, (tex) => {
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const geo = new THREE.PlaneGeometry(4, 4);
            const mesh = new THREE.Mesh(geo, mat);
            
            // åˆå§‹éšè—åœ¨æ ‘ä¸­å¿ƒ
            mesh.position.set(0, 0, 0);
            mesh.scale.set(0.1, 0.1, 0.1);
            scene.add(mesh);
            photoMeshes.push(mesh);
        });
    });
});

/**
 * æ‰‹åŠ¿çŠ¶æ€åˆ‡æ¢é€»è¾‘
 */
function switchState(newState) {
    if (newState === currentState) return;
    currentState = newState;

    particles.forEach((p, i) => {
        const target = newState === 'CLOSE' ? p.tree : p.scatter;
        new TWEEN.Tween(p.current)
            .to({ x: target.x, y: target.y, z: target.z }, 1500)
            .easing(TWEEN.Easing.Quadratic.InOut)
            .start();
    });

    // ç…§ç‰‡åŠ¨ç”»
    photoMeshes.forEach((mesh, i) => {
        let targetPos, targetScale;
        if (newState === 'CLOSE') {
            targetPos = { x: 0, y: 0, z: 0 };
            targetScale = 0.1;
        } else if (newState === 'SCATTER') {
            targetPos = { 
                x: Math.sin(i) * 15, 
                y: Math.cos(i * 1.5) * 15, 
                z: Math.tan(Math.sin(i)) * 5 
            };
            targetScale = 1;
        } else if (newState === 'FOCUS' && i === 0) { // ç®€å•é€»è¾‘ï¼šèšç„¦ç¬¬ä¸€å¼ 
            targetPos = { x: 0, y: 10, z: 20 };
            targetScale = 2.5;
        }
        
        new TWEEN.Tween(mesh.position).to(targetPos, 1000).start();
        new TWEEN.Tween(mesh.scale).to({x: targetScale, y: targetScale, z: targetScale}, 1000).start();
    });
}

/**
 * MediaPipe æ‰‹åŠ¿è¯†åˆ«
 */
function initMediaPipe() {
    const videoElement = document.getElementById('input-video');
    hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => await hands.send({ image: videoElement }),
        width: 640,
        height: 480
    });
    cameraUtils.start();
}

function onResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        // ç®€å•çš„æ‰‹åŠ¿åˆ¤å®šé€»è¾‘
        const isFist = landmarks[8].y > landmarks[6].y && landmarks[12].y > landmarks[10].y;
        const isSpread = landmarks[8].y < landmarks[5].y && landmarks[20].y < landmarks[17].y;
        const isPinch = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y) < 0.05;

        if (isFist) switchState('CLOSE');
        else if (isPinch) switchState('FOCUS');
        else if (isSpread) switchState('SCATTER');

        // ç›¸æœºéšåŠ¨ (æ—‹è½¬è§†è§’)
        const handX = (landmarks[9].x - 0.5) * 2;
        const handY = (landmarks[9].y - 0.5) * 2;
        targetCameraPos.x = handX * 40;
        targetCameraPos.y = -handY * 30 + 10;
    }
}

function animate(time) {
    requestAnimationFrame(animate);
    TWEEN.update(time);

    // æ›´æ–° InstancedMesh
    const dummy = new THREE.Object3D();
    particles.forEach((p, i) => {
        dummy.position.copy(p.current);
        // åˆæ‹¢æ€æ—¶åŠ ä¸€ç‚¹ç‚¹æ—‹è½¬å‘¼å¸æ„Ÿ
        if(currentState === 'CLOSE') {
            dummy.rotation.y = time * 0.0005 + i;
        }
        dummy.updateMatrix();
        instancedMesh.setMatrixAt(i, dummy.matrix);
    });
    instancedMesh.instanceMatrix.needsUpdate = true;

    // å¹³æ»‘ç›¸æœºç§»åŠ¨
    camera.position.lerp(targetCameraPos, 0.05);
    camera.lookAt(0, 5, 0);

    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

init();
</script>
</body>
</html>
